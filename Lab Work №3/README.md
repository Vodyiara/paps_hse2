# Диаграмма компонентов
Данная система имеет 4 микросервиса:
1. WEB-application представляет собой дополнительный микросервис, который может быть использован для веб-интерфейса пользователя.
2. Load Module отвечает за загрузку медицинских снимков пациентов для последующего анализа
3. Visualization Module отвечает за визуализацию результатов анализа и предоставление информации в виде графиков или любом другом удобном формате
4. Analysis Module выполняет анализ медицинских данных с использованием нейросети для диагностирования злокачественных плевральных выпотов
Модуль RestAPI Application является одним из главных компонентом, который предоставляет API для взаимодействия с другими микросервисами и внешними системами.
![paps2 drawio](https://github.com/Vodyiara/pap_hse/blob/main/Lab%20Work%20%E2%84%963/%D0%94%D0%B8%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0%20%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%BE%D0%B21.drawio.png)
# Диаграмма последовательностей
- Диаграмма последовательностей имеет следующие этапы:
  1. Пользователь заходить в свой профиль или региструции в микросервисе WEB-application.
  2. Пользователь отправляет запрос на загрузку медицинских снимков плевральных выпотов через микросервис Load Module, который получает и обрабатывает данные.
  4. После загрузки данных и обработки снимков, данные передаются analysis module, где запускает нейросеть для анализа плевральных выпотов.
  5. Результаты анализа передаются в visualization module, который удобно визуализирует данные с помощью графиков и сохраняют результат в базу данных.
  ![paps2 drawio](https://github.com/Vodyiara/pap_hse/blob/main/Lab%20Work%20%E2%84%963/%D0%94%D0%B8%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0%20%D0%BF%D0%BE%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D0%B5%D0%B91.drawio.png)
# Модель БД
В базе данных имеются следующие сущности
  1) Пациент - содержит имя, дата рождения, пол, адрес, состояние здоровья.
  2) Медицинские данные - хранит результаты анализов пациента(анализ крови, сахара и т.д.).
  3) Результаты анализа - содержит информацию о результатах анализа медицинских данных с использованием нейросети и дате анализа.
  4) Пользователь - хранит информацию о пользователях системы, такую как логин, пароль и роль (например, врач или администратор).
  5) Сессия - отслеживает активные сеансы работы пользователей в системе.
 
![paps2 drawio](https://github.com/Vodyiara/pap_hse/blob/main/Lab%20Work%20%E2%84%963/%D0%91%D0%943.png)

# Применение основных принципов разработки
Клиентский код:

```python
import requests

class DiagnosticsApp:
    def __init__(self):
        self.server_url = "http://example.com/api/diagnostics"
    
    def run(self):
        patient_info = self.get_patient_info()
        symptoms = self.get_symptoms()
        diagnosis = self.send_diagnosis_request(patient_info, symptoms)
        self.display_diagnosis(diagnosis)
    
    def get_patient_info(self):
        # Здесь получаем информацию о пациенте от пользователя
        patient_info = input("Введите информацию о пациенте: ")
        return patient_info
    
    def get_symptoms(self):
        # Здесь получаем симптомы от пользователя
        symptoms = input("Введите симптомы: ")
        # Проверяем, является ли введенная строка путем к файлу
        if symptoms.startswith("file://"):
            # Если это файл, делаем запрос на сервер, передавая его содержимое
            with open(symptoms[len("file://"):], "rb") as f:
                symptoms = {"file": f}
        return symptoms
    
    def send_diagnosis_request(self, patient_info, symptoms):
        # Отправляем запрос на сервер с информацией о пациенте и симптомами
        data = {
            "patient_info": patient_info
        }
        # Если симптомы - файлы, передаем их как файловые объекты
        if isinstance(symptoms, dict):
            files = symptoms
        else:
            # Иначе передаем их как обычные данные
            data["symptoms"] = symptoms
            files = None
        
        response = requests.post(self.server_url, data=data, files=files)
        if response.status_code == 200:
            return response.json()
        else:
            return "Ошибка при отправке запроса"
    
    def display_diagnosis(self, diagnosis):
        # Отображаем диагноз пациенту
        print("Диагноз пациента:", diagnosis)

app = DiagnosticsApp()
app.run()
```
В данном коде реализуются следующие принципы:

1. KISS (Keep It Simple, Stupid)
  Код прост и понятен. Он не содержит избыточных деталей и лишних сложностей, что упрощает его понимание и поддержку.

2. YAGNI (You Ain't Gonna Need It) 
   Код реализует только необходимый функционал для работы с приложением. Не добавлены ненужные фичи, которые могут привести к излишней сложности и перегрузке системы.

3. DRY (Don't Repeat Yourself)
   Код структурирован таким образом, чтобы избежать дублирования кода. Методы get_patient_info, get_symptoms, send_diagnosis_request и display_diagnosis выделены в отдельные функции для повторного использования и улучшения поддерживаемости кода.

4. SOLID
   Класс DiagnosticsApp следует принципу единственной ответственности, так как он отвечает только за запуск приложения и координацию работы других компонентов. Каждый метод класса выполняет только одну задачу. Также класс легко расширяем и поддерживаем, так как методы могут быть заменены или переопределены при необходимости.

Серверный код:

```python
from flask import Flask, request
from PIL import Image
from io import BytesIO

app = Flask(__name__)

@app.route("/api/diagnostics", methods=["POST"])
def diagnose():
    patient_info = request.json["patient_info"]
    # Проверяем, является ли переменная symptoms файлом изображения
    if "symptoms" in request.files:
        symptoms_file = request.files["symptoms"]
        # Обрабатываем изображение
        image = Image.open(BytesIO(symptoms_file.read()))
        # Далее выполняем необходимую обработку изображения, например, анализ
        # Здесь просто возвращаем сообщение с информацией о файле
        return {"diagnosis": "Изображение симптомов: " + symptoms_file.filename}
    else:
        symptoms = request.json["symptoms"]
        diagnosis = process_diagnosis(patient_info, symptoms)
        return {"diagnosis": diagnosis}

def process_diagnosis(patient_info, symptoms):
    # Здесь обрабатываем информацию о пациенте и симптомы
    pass

if __name__ == "__main__":
    app.run()
```

В серверном коде были учтены те же самые принципы:

1. Принцип KISS (Keep It Simple, Stupid) отражен в серверном коде, написанном с использованием фреймворка Flask. Этот фреймворк предоставляет простой и понятный метод создания веб-приложений. Серверный код минимален и выполняет лишь несколько функций - обработку запросов и отправка результатов.

2. Подход YAGNI (You Ain't Gonna Need It) в серверном коде означает, что реализован только необходимый функционал для обработки запроса на диагностику. Здесь не добавлены лишние функции, которые могли бы привести к излишней сложности и перегрузке системы.

3. Принцип DRY (Don't Repeat Yourself) проявляется в выделении функции process_diagnosis для обработки информации о пациенте и симптомах(снимках плевральных выпотов). Эта функция может быть повторно использована в других частях кода, что улучшает его поддерживаемость и исключает дублирование кода.

4. Принцип SOLID в коде сервера отражается через стремление к единственной ответственности. Функция diagnose отвечает исключительно за обработку запроса и возврат результатов. Код легко расширяем и поддерживаем, так как функции могут быть заменены или переопределены при необходимости.


# Дополнительные принципы разработки
Разберем каждый принцип и поймем, насколько он нам походит:

1. BDUF. При создании веб-приложения для диагностики плевральных выпотов следует учитывать, что требования и технические решения могут измениться в процессе разработки. Поэтому преждевременное масштабное проектирование может привести к излишней сложности и избыточности, а также затруднить внесение изменений в дальнейшем. Применение - нежелательно.

2. SoC. Принцип разделения ответственности позволяет разбить функциональность системы на отдельные компоненты, что упрощает поддержку и расширение кода. Например, разделение интерфейса для отправки данных на сервер и отображения результатов анализа позволяет изменять эти части независимо друг от друга. Применение - рекомендуется.

3. MVP. Создание минимально жизнеспособного продукта помогает быстрее вывести его на рынок, получить обратную связь от пользователей и внести необходимые изменения. Это особенно важно для веб-приложений, где быстрый запуск и обновление функциональности играют ключевую роль. Применение - рекомендуется. 

4. PoC. Подтверждение концепции позволяет проверить работоспособность и целесообразность выбранных технических решений, например, обучение нейронной сети для диагностики плевральных выпотов. Это поможет избежать потенциальных проблем и ошибок на более поздних этапах разработки. Применение - рекомендуется.
  
